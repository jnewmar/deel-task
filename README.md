# DEEL BACKEND TASK

## Code styling
For this project it was used JavaScript Standard Style guide (https://standardjs.com/index.html)
To command to run the style guide check is:

¬¥¬¥¬¥¬¥
npm run code-style
¬¥¬¥¬¥¬¥

## Docs

It was used swagger, swagger-ui-express and swagger-editor to create the documentation of the End points

The api/swagger/swagger.yaml file was create using the swagger editor. To run it the command is:

¬¥¬¥¬¥¬¥
npm run swagger:edit
¬¥¬¥¬¥¬¥

And to create src/swagger.json from the swagger.yaml  file is used the command:

¬¥¬¥¬¥¬¥
npm run swagger
¬¥¬¥¬¥¬¥

The src/swagger.json is served by the swagger-ui-express in the url http://localhost:3001/api-docs

Note: The getProfile.js middleware was updated in order to skip the api-docs url

Alternatively there is a Postman collection (DEEL BACKEND TASK.postman_collection.json) in the root path with requests for each EndPoint


## Tests

It was used jest (https://jestjs.io/) and jest-when to create some tests for the functions used to implement the EndPoints
The tests are in the src/controllers/__test__ directory.
To command to run the tests are:

¬¥¬¥¬¥¬¥
npm run test
¬¥¬¥¬¥¬¥

That should result in something like:

¬¥¬¥¬¥¬¥¬¥
npm run test
¬¥¬¥¬¥¬¥¬¥

## EndPoint Notes

### POST /balances/deposit/{user_id}

- Note 1 The value to deposit is informed in cents. per example US$1 should be sent as 100

- Note 2 : Client can't deposit more than 25% his total of jobs to pay. (at the deposit moment). If the client doesn't have values to pay. the restriction will be in the current balance and in the value to deposit. This rule is not applied for logged contractors

- Note 3 : Besides the 25% rule, a user can only deposit if his balance >= the amount to deposit

- Note 4 : The values come from the balance of the logged user to the balance of the informed user

- Note 5 : The source user and destination user could be client or contractor, there is no restriction

- Note 6 : The payment operation will be successful only if all the updates in the source user balance and the destination user balance were successful, if not the operation will fail and no data is updated

### POST /jobs/{job_id}/pay

- Note 1 An unpaid job is a job entry with the paid property not present or with value false

- Note 2 : Only profiles of type client could pay a job

- Note 3 : Only the client in the contract associated with the job could pay it

- Note 4 : A client can only pay if his balance >= the amount to pay

- Note 5 : Only unpaid jobs could be paid it

- Note 6 : The payment operation will be successful only if all the updates in the Job data, client balance, and contractor balance were successful, if not the operation will fail and no data is updated


### GET /admin/best-profession

- Note 1 Besides the documentation ask to return only the contactor that worked in the query time range, this implementation improved that returning all the contractor even the ones that doesn't have payment in the selected range

- Note 2 : Besides the documentation doesn't ask to paginate the returned values, this implementation improved that receiving the limit and offset parameter and returning the the total of contractors

- Note 3 : The start and the end are expect to be in the YYYY-MM-DD format, and the result are filtered from the beginning of the start date to the end of the end date. So, if this Endpoint receives the same day in the start and end date, the values will be filtered from the beginning to the end of this date

- Note 4 : This implementation are assuming the payment dates and the start and end dates to filter are in the same timezone. Handle distinct timezones is out of the scope of this implementation

- Note 5 : The result of this endpoint are descending sorted by the total value received, and for the entries with same amounts of total value received, it is used the first name and last name to sort in an ascending way

- Note 6 : For this Endpoint was chosen to use a raw query in order to avoid any issue related with queries the generated by the sequelize, since this is endpoint is using a non trivial query to retrieve the results

### GET /admin/best-clients

- Note 1 Besides the documentation ask to return only the clients that worked in the query time range, this implementation improved that returning all the clients even the ones that doesn't have payment in the selected range

- Note 2 : Besides the documentation doesn't ask to set an offset in the returned values, this implementation improved that receiving the offset parameter and returning the the total of clients

- Note 3 : The start and the end are expect to be in the YYYY-MM-DD format, and the result are filtered from the beginning of the start date to the end of the end date. So, if this Endpoint receives the same day in the start and end date, the values we be filtered from the beginning to the end of this date

- Note 4 : This implementation are assuming the payment dates and the start and end dates to filter are in the same timezone. Handle distinct timezones is out of the scope of this implementation

- Note 5 : The result of this endpoint are descending sorted by the total value received, and for the entries with same amounts of total value received, it is used the first name and last name to sort in an ascending way

- Note 6 : For this Endpoint was chosen to use a raw query in order to avoid any issue related with queries the generated by the sequelize, since this is endpoint is using a non trivial query to retrieve the results
  
------
üí´ Welcome! üéâ


This backend exercise involves building a Node.js/Express.js app that will serve a REST API. We imagine you should spend around 3 hours at implement this feature.

## Data Models

> **All models are defined in src/model.js**

### Profile
A profile can be either a `client` or a `contractor`. 
clients create contracts with contractors. contractor does jobs for clients and get paid.
Each profile has a balance property.

### Contract
A contract between and client and a contractor.
Contracts have 3 statuses, `new`, `in_progress`, `terminated`. contracts are considered active only when in status `in_progress`
Contracts group jobs within them.

### Job
contractor get paid for jobs by clients under a certain contract.

## Getting Set Up

  
The exercise requires [Node.js](https://nodejs.org/en/) to be installed. We recommend using the LTS version.

  

1. Start by cloning this repository.

  

1. In the repo root directory, run `npm install` to gather all dependencies.

  

1. Next, `npm run seed` will seed the local SQLite database. **Warning: This will drop the database if it exists**. The database lives in a local file `database.sqlite3`.

  

1. Then run `npm start` which should start both the server and the React client.

  

‚ùóÔ∏è **Make sure you commit all changes to the master branch!**

  
  

## Technical Notes

  

- The server is running with [nodemon](https://nodemon.io/) which will automatically restart for you when you modify and save a file.

- The database provider is SQLite, which will store data in a file local to your repository called `database.sqlite3`. The ORM [Sequelize](http://docs.sequelizejs.com/) is on top of it. You should only have to interact with Sequelize - **please spend some time reading sequelize documentation before starting the exercise.**

- To authenticate users use the `getProfile` middleware that is located under src/middleware/getProfile.js. users are authenticated by passing `profile_id` in the request header. after a user is authenticated his profile will be available under `req.profile`. make sure only users that are on the contract can access their contracts.
- The server is running on port 3001.

  

## APIs To Implement 

  

Below is a list of the required API's for the application.

  


1. ***GET*** `/contracts/:id` - This API is broken üòµ! it should return the contract only if it belongs to the profile calling. better fix that!

1. ***GET*** `/contracts` - Returns a list of contracts belonging to a user (client or contractor), the list should only contain non terminated contracts.

1. ***GET*** `/jobs/unpaid` -  Get all unpaid jobs for a user (***either*** a client or contractor), for ***active contracts only***.

1. ***POST*** `/jobs/:job_id/pay` - Pay for a job, a client can only pay if his balance >= the amount to pay. The amount should be moved from the client's balance to the contractor balance.

1. ***POST*** `/balances/deposit/:userId` - Deposits money into the the the balance of a client, a client can't deposit more than 25% his total of jobs to pay. (at the deposit moment)

1. ***GET*** `/admin/best-profession?start=<date>&end=<date>` - Returns the profession that earned the most money (sum of jobs paid) for any contactor that worked in the query time range.

1. ***GET*** `/admin/best-clients?start=<date>&end=<date>&limit=<integer>` - returns the clients the paid the most for jobs in the query time period. limit query parameter should be applied, default limit is 2.
```
 [
    {
        "id": 1,
        "fullName": "Reece Moyer",
        "paid" : 100.3
    },
    {
        "id": 200,
        "fullName": "Debora Martin",
        "paid" : 99
    },
    {
        "id": 22,
        "fullName": "Debora Martin",
        "paid" : 21
    }
]
```

  

## Going Above and Beyond the Requirements

Given the time expectations of this exercise, we don't expect anyone to submit anything super fancy, but if you find yourself with extra time, any extra credit item(s) that showcase your unique strengths would be awesome! üôå

It would be great for example if you'd write some unit test / simple frontend demonstrating calls to your fresh APIs.

  

## Submitting the Assignment

When you have finished the assignment, create a github repository and send us the link.

  

Thank you and good luck! üôè
